<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="xRRgvHNlG#rZ^u`HECiY" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="e=tpW*w[?HBrg2*hEq9I" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum IrButton {" line1="    //% block=&quot;A&quot;" line2="    A_key = 0xA2," line3="    //% block=&quot;B&quot;" line4="    B_key = 0x62," line5="    //% block=&quot;C&quot;" line6="    C_key = 0xE2," line7="    //% block=&quot;D&quot;" line8="    D_key = 0x22," line9="    //% block=&quot;▲&quot;" line10="    Up = 0x02," line11="    //% block=&quot;E&quot;" line12="    E_key = 0xC2," line13="    //% block=&quot;◀&quot;" line14="    Left = 0xE0," line15="    //% block=&quot;⚙&quot;" line16="    Ok = 0xA8," line17="    //% block=&quot;▶&quot;" line18="    Right = 0x90," line19="    //% block=&quot;0&quot;" line20="    Number_0 = 0x68," line21="    //% block=&quot;▼&quot;" line22="    Down = 0x98," line23="    //% block=&quot;F&quot;" line24="    F_key = 0xB0," line25="    //% block=&quot;1&quot;" line26="    Number_1 = 0x30," line27="    //% block=&quot;2&quot;" line28="    Number_2 = 0x18," line29="    //% block=&quot;3&quot;" line30="    Number_3 = 0x7A," line31="    //% block=&quot;4&quot;" line32="    Number_4 = 0x10," line33="    //% block=&quot;5&quot;" line34="    Number_5 = 0x38," line35="    //% block=&quot;6&quot;" line36="    Number_6 = 0x5A," line37="    //% block=&quot;7&quot;" line38="    Number_7 = 0x42," line39="    //% block=&quot;8&quot;" line40="    Number_8 = 0x4A," line41="    //% block=&quot;9&quot;" line42="    Number_9 = 0x52," line43="}" numlines="44"></mutation><next><block type="typescript_statement" id="g/+Au^}Gl96H_tjXj/]^" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum IrButtonAction {" line1="    //% block=&quot;pressed&quot;" line2="    Pressed = 0," line3="    //% block=&quot;released&quot;" line4="    Released = 1," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="RjsE;_1i,JNftf7NmE|5" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum IrProtocol {" line1="    //% block=&quot;Keyestudio&quot;" line2="    Keyestudio = 0," line3="    //% block=&quot;NEC&quot;" line4="    NEC = 1," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="b1.V1?[UDuk?D8|Bu@OC" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace luckycar {" line1="    /**" line2="     * IR receiver" line3="     */" line4="    export namespace background {" line5="" line6="        export enum Thread {" line7="            Priority = 0," line8="            UserCallback = 1," line9="        }" line10="" line11="        export enum Mode {" line12="            Repeat," line13="            Once," line14="        }" line15="" line16="        class Executor {" line17="            _newJobs: Job[] = undefined;" line18="            _jobsToRemove: number[] = undefined;" line19="            _pause: number = 100;" line20="            _type: Thread;" line21="" line22="            constructor(type: Thread) {" line23="                this._type = type;" line24="                this._newJobs = [];" line25="                this._jobsToRemove = [];" line26="                control.runInParallel(() =&gt; this.loop());" line27="            }" line28="" line29="            push(task: () =&gt; void, delay: number, mode: Mode): number {" line30="                if (delay &gt; 0 &amp;&amp; delay &lt; this._pause &amp;&amp; mode === Mode.Repeat) {" line31="                    this._pause = Math.floor(delay);" line32="                }" line33="                const job = new Job(task, delay, mode);" line34="                this._newJobs.push(job);" line35="                return job.id;" line36="            }" line37="" line38="            cancel(jobId: number) {" line39="                this._jobsToRemove.push(jobId);" line40="            }" line41="" line42="            loop(): void {" line43="                const _jobs: Job[] = [];" line44="" line45="                let previous = control.millis();" line46="" line47="                while (true) {" line48="                    const now = control.millis();" line49="                    const delta = now - previous;" line50="                    previous = now;" line51="" line52="                    // Add new jobs" line53="                    this._newJobs.forEach(function (job: Job, index: number) {" line54="                        _jobs.push(job);" line55="                    });" line56="                    this._newJobs = [];" line57="" line58="                    // Cancel jobs" line59="                    this._jobsToRemove.forEach(function (jobId: number, index: number) {" line60="                        for (let i = _jobs.length - 1; i &gt;= 0; i--) {" line61="                            const job2 = _jobs[i];" line62="                            if (job2.id == jobId) {" line63="                                _jobs.removeAt(i);" line64="                                break;" line65="                            }" line66="                        }" line67="                    });" line68="                    this._jobsToRemove = []" line69="" line70="" line71="                    // Execute all jobs" line72="                    if (this._type === Thread.Priority) {" line73="                        // newest first" line74="                        for (let j = _jobs.length - 1; j &gt;= 0; j--) {" line75="                            if (_jobs[j].run(delta)) {" line76="                                this._jobsToRemove.push(_jobs[j].id)" line77="                            }" line78="                        }" line79="                    } else {" line80="                        // Execute in order of schedule" line81="                        for (let k = 0; k &lt; _jobs.length; k++) {" line82="                            if (_jobs[k].run(delta)) {" line83="                                this._jobsToRemove.push(_jobs[k].id)" line84="                            }" line85="                        }" line86="                    }" line87="" line88="                    basic.pause(this._pause);" line89="                }" line90="            }" line91="        }" line92="" line93="        class Job {" line94="            id: number;" line95="            func: () =&gt; void;" line96="            delay: number;" line97="            remaining: number;" line98="            mode: Mode;" line99="" line100="            constructor(func: () =&gt; void, delay: number, mode: Mode) {" line101="                this.id = randint(0, 2147483647)" line102="                this.func = func;" line103="                this.delay = delay;" line104="                this.remaining = delay;" line105="                this.mode = mode;" line106="            }" line107="" line108="            run(delta: number): boolean {" line109="                if (delta &lt;= 0) {" line110="                    return false;" line111="                }" line112="" line113="                this.remaining -= delta;" line114="                if (this.remaining &gt; 0) {" line115="                    return false;" line116="                }" line117="" line118="                switch (this.mode) {" line119="                    case Mode.Once:" line120="                        this.func();" line121="                        basic.pause(0);" line122="                        return true;" line123="                    case Mode.Repeat:" line124="                        this.func();" line125="                        this.remaining = this.delay;" line126="                        basic.pause(0);" line127="                        return false;" line128="                }" line129="            }" line130="        }" line131="" line132="        const queues: Executor[] = [];" line133="" line134="        export function schedule(" line135="            func: () =&gt; void," line136="            type: Thread," line137="            mode: Mode," line138="            delay: number," line139="        ): number {" line140="            if (!func || delay &lt; 0) return 0;" line141="" line142="            if (!queues[type]) {" line143="                queues[type] = new Executor(type);" line144="            }" line145="" line146="            return queues[type].push(func, delay, mode);" line147="        }" line148="" line149="        export function remove(type: Thread, jobId: number): void {" line150="            if (queues[type]) {" line151="                queues[type].cancel(jobId);" line152="            }" line153="        }" line154="    }" line155="    ///////////////////////" line156="    let irState: IrState;" line157="" line158="    const IR_REPEAT = 256;" line159="    const IR_INCOMPLETE = 257;" line160="    const IR_DATAGRAM = 258;" line161="" line162="    const REPEAT_TIMEOUT_MS = 120;" line163="" line164="    interface IrState {" line165="        protocol: IrProtocol;" line166="        hasNewDatagram: boolean;" line167="        bitsReceived: uint8;" line168="        addressSectionBits: uint16;" line169="        commandSectionBits: uint16;" line170="        hiword: uint16;" line171="        loword: uint16;" line172="        activeCommand: number;" line173="        repeatTimeout: number;" line174="        onIrButtonPressed: IrButtonHandler[];" line175="        onIrButtonReleased: IrButtonHandler[];" line176="        onIrDatagram: () =&gt; void;" line177="    }" line178="    class IrButtonHandler {" line179="        irButton: IrButton;" line180="        onEvent: () =&gt; void;" line181="" line182="        constructor(" line183="            irButton: IrButton," line184="            onEvent: () =&gt; void" line185="        ) {" line186="            this.irButton = irButton;" line187="            this.onEvent = onEvent;" line188="        }" line189="    }" line190="" line191="" line192="    function appendBitToDatagram(bit: number): number {" line193="        irState.bitsReceived += 1;" line194="" line195="        if (irState.bitsReceived &lt;= 8) {" line196="            irState.hiword = (irState.hiword &lt;&lt; 1) + bit;" line197="            if (irState.protocol === IrProtocol.Keyestudio &amp;&amp; bit === 1) {" line198="                // recover from missing message bits at the beginning" line199="                // Keyestudio address is 0 and thus missing bits can be detected" line200="                // by checking for the first inverse address bit (which is a 1)" line201="                irState.bitsReceived = 9;" line202="                irState.hiword = 1;" line203="            }" line204="        } else if (irState.bitsReceived &lt;= 16) {" line205="            irState.hiword = (irState.hiword &lt;&lt; 1) + bit;" line206="        } else if (irState.bitsReceived &lt;= 32) {" line207="            irState.loword = (irState.loword &lt;&lt; 1) + bit;" line208="        }" line209="" line210="        if (irState.bitsReceived === 32) {" line211="            irState.addressSectionBits = irState.hiword &amp; 0xffff;" line212="            irState.commandSectionBits = irState.loword &amp; 0xffff;" line213="            return IR_DATAGRAM;" line214="        } else {" line215="            return IR_INCOMPLETE;" line216="        }" line217="    }" line218="" line219="    function decode(markAndSpace: number): number {" line220="        if (markAndSpace &lt; 1600) {" line221="            // low bit" line222="            return appendBitToDatagram(0);" line223="        } else if (markAndSpace &lt; 2700) {" line224="            // high bit" line225="            return appendBitToDatagram(1);" line226="        }" line227="" line228="        irState.bitsReceived = 0;" line229="" line230="        if (markAndSpace &lt; 12500) {" line231="            // Repeat detected" line232="            return IR_REPEAT;" line233="        } else if (markAndSpace &lt; 14500) {" line234="            // Start detected" line235="            return IR_INCOMPLETE;" line236="        } else {" line237="            return IR_INCOMPLETE;" line238="        }" line239="    }" line240="" line241="    function enableIrMarkSpaceDetection(pin: DigitalPin) {" line242="        pins.setPull(pin, PinPullMode.PullNone);" line243="" line244="        let mark = 0;" line245="        let space = 0;" line246="" line247="        pins.onPulsed(pin, PulseValue.Low, () =&gt; {" line248="            // HIGH, see https://github.com/microsoft/pxt-microbit/issues/1416" line249="            mark = pins.pulseDuration();" line250="        });" line251="" line252="        pins.onPulsed(pin, PulseValue.High, () =&gt; {" line253="            // LOW" line254="            space = pins.pulseDuration();" line255="            const status = decode(mark + space);" line256="" line257="            if (status !== IR_INCOMPLETE) {" line258="                handleIrEvent(status);" line259="            }" line260="        });" line261="    }" line262="" line263="    function handleIrEvent(irEvent: number) {" line264="" line265="        // Refresh repeat timer" line266="        if (irEvent === IR_DATAGRAM || irEvent === IR_REPEAT) {" line267="            irState.repeatTimeout = input.runningTime() + REPEAT_TIMEOUT_MS;" line268="        }" line269="" line270="        if (irEvent === IR_DATAGRAM) {" line271="            irState.hasNewDatagram = true;" line272="" line273="            if (irState.onIrDatagram) {" line274="                background.schedule(irState.onIrDatagram, background.Thread.UserCallback, background.Mode.Once, 0);" line275="            }" line276="" line277="            const newCommand = irState.commandSectionBits &gt;&gt; 8;" line278="" line279="            // Process a new command" line280="            if (newCommand !== irState.activeCommand) {" line281="" line282="                if (irState.activeCommand &gt;= 0) {" line283="                    const releasedHandler = irState.onIrButtonReleased.find(h =&gt; h.irButton === irState.activeCommand || IrButton.A_key === h.irButton);" line284="                    if (releasedHandler) {" line285="                        background.schedule(releasedHandler.onEvent, background.Thread.UserCallback, background.Mode.Once, 0);" line286="                    }" line287="                }" line288="" line289="                const pressedHandler = irState.onIrButtonPressed.find(h =&gt; h.irButton === newCommand || IrButton.A_key === h.irButton);" line290="                if (pressedHandler) {" line291="                    background.schedule(pressedHandler.onEvent, background.Thread.UserCallback, background.Mode.Once, 0);" line292="                }" line293="" line294="                irState.activeCommand = newCommand;" line295="            }" line296="        }" line297="    }" line298="" line299="    function initIrState() {" line300="        if (irState) {" line301="            return;" line302="        }" line303="" line304="        irState = {" line305="            protocol: undefined," line306="            bitsReceived: 0," line307="            hasNewDatagram: false," line308="            addressSectionBits: 0," line309="            commandSectionBits: 0," line310="            hiword: 0, // TODO replace with uint32" line311="            loword: 0," line312="            activeCommand: -1," line313="            repeatTimeout: 0," line314="            onIrButtonPressed: []," line315="            onIrButtonReleased: []," line316="            onIrDatagram: undefined," line317="        };" line318="    }" line319="    ///////////////////////" line320="    /**" line321="    * Connects to the IR receiver module at the specified pin and configures the IR protocol." line322="    * @param pin IR receiver pin, eg: DigitalPin.P0" line323="    * @param protocol IR protocol, eg: IrProtocol.Keyestudio" line324="    */" line325="    //% subcategory=&quot;IR Receiver&quot;" line326="    //% blockId=&quot;luckycar_infrared_connect_receiver&quot;" line327="    //% block=&quot;connect IR receiver at pin %pin and decode %protocol&quot;" line328="    //% pin.fieldEditor=&quot;gridpicker&quot;" line329="    //% pin.fieldOptions.columns=4" line330="    //% pin.fieldOptions.tooltips=&quot;false&quot;" line331="    //% weight=90" line332="    export function connectIrReceiver(" line333="        pin: DigitalPin," line334="        protocol: IrProtocol" line335="    ): void {" line336="        initIrState();" line337="" line338="        if (irState.protocol) {" line339="            return;" line340="        }" line341="" line342="        irState.protocol = protocol;" line343="" line344="        enableIrMarkSpaceDetection(pin);" line345="" line346="        background.schedule(notifyIrEvents, background.Thread.Priority, background.Mode.Repeat, REPEAT_TIMEOUT_MS);" line347="    }" line348="" line349="    function notifyIrEvents() {" line350="        if (irState.activeCommand === -1) {" line351="            // skip to save CPU cylces" line352="        } else {" line353="            const now2 = input.runningTime();" line354="            if (now2 &gt; irState.repeatTimeout) {" line355="                // repeat timed out" line356="" line357="                const handler = irState.onIrButtonReleased.find(h =&gt; h.irButton === irState.activeCommand || IrButton.A_key === h.irButton);" line358="                if (handler) {" line359="                    background.schedule(handler.onEvent, background.Thread.UserCallback, background.Mode.Once, 0);" line360="                }" line361="" line362="                irState.bitsReceived = 0;" line363="                irState.activeCommand = -1;" line364="            }" line365="        }" line366="    }" line367="    /**" line368="       * Do something when a specific button is pressed or released on the remote control." line369="       * @param button the button to be checked" line370="       * @param action the trigger action" line371="       * @param handler body code to run when the event is raised" line372="       */" line373="    //% subcategory=&quot;IR Receiver&quot;" line374="    //% blockId=luckycar_infrared_on_ir_button" line375="    //% block=&quot;on IR button | %button | %action&quot;" line376="    //% button.fieldEditor=&quot;gridpicker&quot;" line377="    //% button.fieldOptions.columns=3" line378="    //% button.fieldOptions.tooltips=&quot;false&quot;" line379="    //% weight=50" line380="    export function onIrButton(" line381="        button: IrButton," line382="        action: IrButtonAction," line383="        handler: () =&gt; void" line384="    ) {" line385="        initIrState();" line386="        if (action === IrButtonAction.Pressed) {" line387="            irState.onIrButtonPressed.push(new IrButtonHandler(button, handler));" line388="        }" line389="        else {" line390="            irState.onIrButtonReleased.push(new IrButtonHandler(button, handler));" line391="        }" line392="    }" line393="    /**" line394="       * Returns the code of the IR button that was pressed last. Returns -1 (IrButton.Any) if no button has been pressed yet." line395="       */" line396="    //% subcategory=&quot;IR Receiver&quot;" line397="    //% blockId=luckycar_infrared_ir_button_pressed" line398="    //% block=&quot;IR button&quot;" line399="    //% weight=70" line400="    export function irButton(): number {" line401="        basic.pause(0); // Yield to support background processing when called in tight loops" line402="        if (!irState) {" line403="            return IrButton.A_key;" line404="        }" line405="        return irState.commandSectionBits &gt;&gt; 8;" line406="    }" line407="" line408="    /**" line409="     * Do something when an IR datagram is received." line410="     * @param handler body code to run when the event is raised" line411="     */" line412="    //% subcategory=&quot;IR Receiver&quot;" line413="    //% blockId=luckycar_infrared_on_ir_datagram" line414="    //% block=&quot;on IR datagram received&quot;" line415="    //% weight=40" line416="    export function onIrDatagram(handler: () =&gt; void) {" line417="        initIrState();" line418="        irState.onIrDatagram = handler;" line419="    }" line420="" line421="    /**" line422="     * Returns the IR datagram as 32-bit hexadecimal string." line423="     * The last received datagram is returned or &quot;0x00000000&quot; if no data has been received yet." line424="     */" line425="    //% subcategory=&quot;IR Receiver&quot;" line426="    //% blockId=luckycar_infrared_ir_datagram" line427="    //% block=&quot;IR datagram&quot;" line428="    //% weight=30" line429="    export function irDatagram(): string {" line430="        basic.pause(0); // Yield to support background processing when called in tight loops" line431="        initIrState();" line432="        return (" line433="            &quot;0x&quot; +" line434="            ir_rec_to16BitHex(irState.addressSectionBits) +" line435="            ir_rec_to16BitHex(irState.commandSectionBits)" line436="        );" line437="    }" line438="" line439="    /**" line440="     * Returns true if any IR data was received since the last call of this function. False otherwise." line441="     */" line442="    //% subcategory=&quot;IR Receiver&quot;" line443="    //% blockId=luckycar_infrared_was_any_ir_datagram_received" line444="    //% block=&quot;IR data was received&quot;" line445="    //% weight=80" line446="    export function wasIrDataReceived(): boolean {" line447="        basic.pause(0); // Yield to support background processing when called in tight loops" line448="        initIrState();" line449="        if (irState.hasNewDatagram) {" line450="            irState.hasNewDatagram = false;" line451="            return true;" line452="        } else {" line453="            return false;" line454="        }" line455="    }" line456="" line457="    /**" line458="     * Returns the command code of a specific IR button." line459="     * @param button the button" line460="     */" line461="    //% subcategory=&quot;IR Receiver&quot;" line462="    //% blockId=luckycar_infrared_button_code" line463="    //% button.fieldEditor=&quot;gridpicker&quot;" line464="    //% button.fieldOptions.columns=3" line465="    //% button.fieldOptions.tooltips=&quot;false&quot;" line466="    //% block=&quot;IR button code %button&quot;" line467="    //% weight=60" line468="    export function irButtonCode(button: IrButton): number {" line469="        basic.pause(0); // Yield to support background processing when called in tight loops" line470="        return button as number;" line471="    }" line472="    function ir_rec_to16BitHex(value: number): string {" line473="        let hex = &quot;&quot;;" line474="        for (let pos = 0; pos &lt; 4; pos++) {" line475="            let remainder = value % 16;" line476="            if (remainder &lt; 10) {" line477="                hex = remainder.toString() + hex;" line478="            } else {" line479="                hex = String.fromCharCode(55 + remainder) + hex;" line480="            }" line481="            value = Math.idiv(value, 16);" line482="        }" line483="        return hex;" line484="    }" line485="" line486="    /**" line487="     * 小车马达、循迹控制" line488="     */" line489="" line490="    let _initEvents = true" line491="    /**" line492="    * Unit of Ultrasound Module" line493="    */" line494="    export enum SonarUnit {" line495="        //% block=&quot;cm&quot;" line496="        Centimeters," line497="        //% block=&quot;inches&quot;" line498="        Inches" line499="    }" line500="    /**" line501="    * Select the motor on the left or right" line502="    */" line503="    export enum MotorsList {" line504="        //% blockId=&quot;M1&quot; block=&quot;M1&quot;" line505="        M1 = 0," line506="        //% blockId=&quot;M2&quot; block=&quot;M2&quot;" line507="        M2 = 1" line508="    }" line509="" line510="    export enum Direction {" line511="        //% block=&quot;Forward&quot; enumval=0" line512="        forward," line513="        //% block=&quot;Backward&quot; enumval=1" line514="        backward," line515="        //% block=&quot;Left&quot; enumval=2" line516="        left," line517="        //% block=&quot;Right&quot; enumval=3" line518="        right" line519="    }" line520="    /**" line521="     * Pins used to generate events" line522="     */" line523="    export enum CenterTrackPins {" line524="        //% block=&quot;Left&quot; " line525="        Left = DAL.MICROBIT_ID_IO_P11," line526="        //% block=&quot;Right&quot; " line527="        Right = DAL.MICROBIT_ID_IO_P15" line528="    }" line529="    /**" line530="    * Line Sensor events    MICROBIT_PIN_EVT_RISE" line531="    */" line532="    export enum CenterTrackEvents {" line533="        //% block=&quot;Found&quot; " line534="        FindLine = DAL.MICROBIT_PIN_EVT_FALL," line535="        //% block=&quot;Lost&quot; " line536="        LoseLine = DAL.MICROBIT_PIN_EVT_RISE" line537="    }" line538="" line539="    /**" line540="    * Status List of Center Tracking Modules" line541="    */" line542="    export enum CenterTrackingState {" line543="        //% block=&quot;● ●&quot; enumval=0" line544="        C_L_R_line," line545="" line546="        //% block=&quot;◌ ●&quot; enumval=1" line547="        C_L_unline_R_line," line548="" line549="        //% block=&quot;● ◌&quot; enumval=2" line550="        C_L_line_R_unline," line551="" line552="        //% block=&quot;◌ ◌&quot; enumval=3" line553="        C_L_R_unline" line554="    }" line555="    /**" line556="    * Status List of Side Tracking Modules" line557="    */" line558="    export enum SideTrackingState {" line559="        //% block=&quot;● ●&quot; enumval=0" line560="        S_L_R_line," line561="" line562="        //% block=&quot;◌ ●&quot; enumval=1" line563="        S_L_unline_R_line," line564="" line565="        //% block=&quot;● ◌&quot; enumval=2" line566="        S_L_line_R_unline," line567="" line568="        //% block=&quot;◌ ◌&quot; enumval=3" line569="        S_L_R_unline" line570="    }" line571="" line572="    /**" line573="     * TODO: Set the speed of left and right wheels. " line574="     * @param lspeed Left wheel speed , eg: 100" line575="     * @param rspeed Right wheel speed, eg: -100" line576="     */" line577="    //% blockId=MotorRun block=&quot;Set left wheel speed %lspeed\\% |right wheel speed %rspeed\\%&quot;" line578="    //% lspeed.min=-100 lspeed.max=100" line579="    //% rspeed.min=-100 rspeed.max=100" line580="    //% weight=100" line581="    export function motors(lspeed: number = 50, rspeed: number = 50): void {" line582="        if (lspeed &gt; 100) {" line583="            lspeed = 100;" line584="        } else if (lspeed &lt; -100) {" line585="            lspeed = -100;" line586="        }" line587="        if (rspeed &gt; 100) {" line588="            rspeed = 100;" line589="        } else if (rspeed &lt; -100) {" line590="            rspeed = -100;" line591="        }" line592="" line593="        if (lspeed &gt;= 0) {" line594="            pins.analogWritePin(AnalogPin.P0, lspeed == 100 ? 1023 : (lspeed * 1024) / 100);" line595="            pins.digitalWritePin(DigitalPin.P12, 0);" line596="        }" line597="        else {" line598="            lspeed = Math.abs(lspeed);" line599="            pins.analogWritePin(AnalogPin.P0, ((100 - lspeed) * 1024) / 100);" line600="            pins.digitalWritePin(DigitalPin.P12, 1);" line601="        }" line602="        if (rspeed &gt;= 0) {" line603="            pins.analogWritePin(AnalogPin.P1, rspeed == 100 ? 1023 : (rspeed * 1024) / 100);" line604="            pins.digitalWritePin(DigitalPin.P8, 0);" line605="        }" line606="        else {" line607="            rspeed = Math.abs(rspeed);" line608="            pins.analogWritePin(AnalogPin.P1, ((100 - rspeed) * 1024) / 100);" line609="            pins.digitalWritePin(DigitalPin.P8, 1);" line610="        }" line611="    }" line612="    /**" line613="    * TODO: Full speed operation lasts for 10 seconds,speed is 100." line614="    * @param dir Driving direction, eg: Direction.forward" line615="    * @param speed Running speed, eg: 50" line616="    * @param time Travel time, eg: 5" line617="    */" line618="    //% blockId=luckycar_move_time block=&quot;Go %dir at speed%speed\\% for %time seconds&quot;" line619="    //% weight=95" line620="    export function moveTime(dir: Direction, speed: number, time: number): void {" line621="        if (dir == 0) {" line622="            motors(speed, speed);" line623="            basic.pause(time * 1000)" line624="            motors(0, 0)" line625="        }" line626="        if (dir == 1) {" line627="            motors(-speed, -speed);" line628="            basic.pause(time * 1000)" line629="            motors(0, 0)" line630="        }" line631="        if (dir == 2) {" line632="            motors(-speed, speed);" line633="            basic.pause(time * 1000)" line634="            motors(0, 0)" line635="        }" line636="        if (dir == 3) {" line637="            motors(speed, -speed);" line638="            basic.pause(time * 1000)" line639="            motors(0, 0)" line640="        }" line641="    }" line642="    /**" line643="    * TODO: full speed move forward,speed is 100." line644="    */" line645="    //% blockId=Luckyebot_forward block=&quot;Go straight at full speed&quot;" line646="    //% weight=90" line647="    export function forward(): void {" line648="        pins.analogWritePin(AnalogPin.P0, 1023);" line649="        pins.digitalWritePin(DigitalPin.P12, 0);" line650="" line651="        pins.analogWritePin(AnalogPin.P1, 1023);" line652="        pins.digitalWritePin(DigitalPin.P8, 0);" line653="    }" line654="" line655="" line656="    /**" line657="    * TODO: full speed move back,speed is -100." line658="    */" line659="    //% blockId=luckycar_back block=&quot;Reverse at full speed&quot;" line660="    //% weight=85" line661="    export function backforward(): void {" line662="        pins.analogWritePin(AnalogPin.P0, 0);" line663="        pins.digitalWritePin(DigitalPin.P12, 1);" line664="" line665="        pins.analogWritePin(AnalogPin.P1, 0);" line666="        pins.digitalWritePin(DigitalPin.P8, 1);" line667="" line668="    }" line669="    /**" line670="    * TODO: full speed turnleft." line671="    */" line672="    //% blockId=luckycar_left block=&quot;Turn left at full speed&quot;" line673="    //% weight=80" line674="    export function turnleft(): void {" line675="        pins.analogWritePin(AnalogPin.P0, 1023);" line676="        pins.digitalWritePin(DigitalPin.P12, 0);" line677="" line678="        pins.analogWritePin(AnalogPin.P1, 0);" line679="        pins.digitalWritePin(DigitalPin.P8, 1);" line680="    }" line681="    /**" line682="    * TODO: full speed turnright." line683="    */" line684="    //% blockId=luckycar_right block=&quot;Turn right at full speed&quot;" line685="    //% weight=75" line686="    export function turnright(): void {" line687="        pins.analogWritePin(AnalogPin.P0, 0);" line688="        pins.digitalWritePin(DigitalPin.P12, 1);" line689="" line690="        pins.analogWritePin(AnalogPin.P1, 1023);" line691="        pins.digitalWritePin(DigitalPin.P8, 0);" line692="    }" line693="    /**" line694="    * TODO: stopcar" line695="    */" line696="    //% blockId=luckycar_stopcar block=&quot;Stop car immediatly&quot;" line697="    //% weight=70" line698="    export function stopcar(): void {" line699="        motors(0, 0)" line700="    }" line701="" line702="    /**" line703="    * Judging the Current Status of Center Tracking Module. " line704="    * @param state Four states of Center tracking module, eg: TrackingState.C_L_R_line" line705="    */" line706="    //% blockId=ringbitcar_center_tracking block=&quot;Center tracking state is %state&quot;" line707="    //% weight=65" line708="    export function centertracking(state: CenterTrackingState): boolean {" line709="        pins.setPull(DigitalPin.P11, PinPullMode.PullNone)" line710="        pins.setPull(DigitalPin.P15, PinPullMode.PullNone)" line711="        let center_left_tracking = pins.digitalReadPin(DigitalPin.P11);" line712="        let center_right_tracking = pins.digitalReadPin(DigitalPin.P15);" line713="        if (center_left_tracking == 0 &amp;&amp; center_right_tracking == 0 &amp;&amp; state == 0) {" line714="            return true;" line715="        }" line716="        else if (center_left_tracking == 1 &amp;&amp; center_right_tracking == 0 &amp;&amp; state == 1) {" line717="            return true;" line718="        }" line719="        else if (center_left_tracking == 0 &amp;&amp; center_right_tracking == 1 &amp;&amp; state == 2) {" line720="            return true;" line721="        }" line722="        else if (center_left_tracking == 1 &amp;&amp; center_left_tracking == 1 &amp;&amp; state == 3) {" line723="            return true;" line724="        }" line725="        else {" line726="            return false;" line727="        }" line728="    }" line729="    /**" line730="    * TODO: track one side" line731="    * @param side Line sensor edge , eg: CenterTrackPins.Left" line732="    * @param state Line sensor status, eg: CenterTrackEvents.FindLine" line733="    */" line734="    //% block=&quot;%side line sensor %state&quot;" line735="    //% state.fieldEditor=&quot;gridpicker&quot; state.fieldOptions.columns=2" line736="    //% side.fieldEditor=&quot;gridpicker&quot; side.fieldOptions.columns=2" line737="    //% weight=60" line738="    export function trackSide(side: CenterTrackPins, state: CenterTrackEvents): boolean {" line739="        pins.setPull(DigitalPin.P11, PinPullMode.PullNone)" line740="        pins.setPull(DigitalPin.P15, PinPullMode.PullNone)" line741="        let left_tracking = pins.digitalReadPin(DigitalPin.P11);" line742="        let right_tracking = pins.digitalReadPin(DigitalPin.P15);" line743="        if (side == 0 &amp;&amp; state == 1 &amp;&amp; left_tracking == 1) {" line744="            return true;" line745="        }" line746="        else if (side == 0 &amp;&amp; state == 0 &amp;&amp; left_tracking == 0) {" line747="            return true;" line748="        }" line749="        else if (side == 1 &amp;&amp; state == 1 &amp;&amp; right_tracking == 1) {" line750="            return true;" line751="        }" line752="        else if (side == 1 &amp;&amp; state == 0 &amp;&amp; right_tracking == 0) {" line753="            return true;" line754="        }" line755="        else {" line756="            return false;" line757="        }" line758="    }" line759="" line760="    /**" line761="    * Cars can extend the ultrasonic function to prevent collisions and other functions.. " line762="    * @param Sonarunit two states of ultrasonic module, eg: Centimeters" line763="    */" line764="    //% blockId=ultrasonic block=&quot;HC-SR04 Sonar unit %unit&quot;" line765="    //% weight=55" line766="    export function ultrasonic(unit: SonarUnit, maxCmDistance = 500): number {" line767="        // send pulse" line768="        pins.setPull(DigitalPin.P14, PinPullMode.PullNone);" line769="        pins.digitalWritePin(DigitalPin.P14, 0);" line770="        control.waitMicros(2);" line771="        pins.digitalWritePin(DigitalPin.P14, 1);" line772="        control.waitMicros(10);" line773="        pins.digitalWritePin(DigitalPin.P14, 0);" line774="        // read pulse" line775="        const d = pins.pulseIn(DigitalPin.P13, PulseValue.High, maxCmDistance * 50);" line776="        switch (unit) {" line777="            case SonarUnit.Centimeters:" line778="                return Math.floor(d * 9 / 6 / 58);" line779="            case SonarUnit.Inches:" line780="                return Math.floor(d * 9 / 6 / 148);" line781="            default:" line782="                return d;" line783="        }" line784="    }" line785="" line786="    /**" line787="    * TODO: Runs when line sensor finds or loses." line788="    */" line789="    //% block=&quot;On %sensor| line %event&quot;" line790="    //% sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=2" line791="    //% event.fieldEditor=&quot;gridpicker&quot; event.fieldOptions.columns=2" line792="    //% weight=50" line793="    export function trackEvent(sensor: CenterTrackPins, event: CenterTrackEvents, handler: Action) {" line794="        initEvents();" line795="        control.onEvent(&lt;number&gt;sensor, &lt;number&gt;event, handler);" line796="    }" line797="" line798="    /**" line799="     * TODO: Set the angle of servo. " line800="     * @param angle angle of servo, eg: 90" line801="     */" line802="    //% blockId=luckycar_servo block=&quot;Set servo angle to %angle °&quot;" line803="    //% angle.shadow=&quot;protractorPicker&quot;" line804="    //% weight=45" line805="    export function setServo(angle: number = 180): void {" line806="        pins.servoWritePin(AnalogPin.P4, angle)" line807="    }" line808="" line809="    /**" line810="     * TODO: Set the AudioPin. " line811="     */" line812="    //% blockId=luckycar_AudioPin block=&quot;Set AudioPin on P9&quot;" line813="    //% weight=40" line814="    export function setAudionPinFixed(): void {" line815="        pins.setAudioPin(AnalogPin.P9)" line816="    }" line817="" line818="" line819="    function initEvents(): void {" line820="        if (_initEvents) {" line821="            pins.setEvents(DigitalPin.P11, PinEventType.Edge);" line822="            pins.setEvents(DigitalPin.P11, PinEventType.Edge);" line823="            _initEvents = false;" line824="        }" line825="    }" line826="" line827="" line828="" line829="}" numlines="830"></mutation></block></next></block></next></block></next></block></statement></block></xml>